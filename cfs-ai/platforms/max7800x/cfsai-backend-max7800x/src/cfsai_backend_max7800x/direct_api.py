# Copyright (c) 2025 Analog Devices, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
from pathlib import Path

from pydantic import TypeAdapter

from cfsai_backend_max7800x.exceptions import IzerError
from cfsai_backend_max7800x.extensions import CfsaiIzerExtensions
from cfsai_backend_max7800x.izer import CNNGeneratorArgs, codegen
from cfsai_types.backend_api import BackendApi
from cfsai_types.config.verified import VerifiedBackendConfig
from cfsai_types.logging import file_created_event

logger = logging.getLogger(__name__)

def _parse_input_shape(s: str) -> list[int]:
    dims = s.strip().split(',')
    try:
        res = [int(x) for x in dims]
    except Exception:
        raise
    return res

class IzerApi(BackendApi):
    """Izer backend API implementation."""

    def convert_to_cfs(
            self, 
            code_path: Path, 
            report_dir: Path, 
        ) -> None:
        """
        Post process the code generated by the ai8x-synthesis tool.

        Args:
            code_path: Path to the generated code.
            report_dir: Directory to report generated file.
        """
        main_c_file = code_path / 'main.c'

        if main_c_file.exists():
            main_c_file.unlink()

        allowed_extensions = {
            '.c', '.h','.cpp', '.hpp','.cc', '.cxx', '.hxx'
        }
        for item in code_path.iterdir():
            if item.is_file() and item.suffix in allowed_extensions:
                file_created_event(
                    logger,
                    report_dir / item.name
                )


    def build(self, cfgs: VerifiedBackendConfig) -> None:
        """
        Izer build api implementation.

        Args:
            cfgs: Verified containerized backend configuration.
        
        Raises:
            IzerError: If the backend configuration has more than one model
                configuration (izer can only target the cnn with one owner).
            IzerError: If izer extensions do not adhere to their schema.
            IzerError: If the model file could not be found.
            IzerError: If code generation failed. 
        """
        if len(cfgs.items) > 1:
            raise IzerError('Accelerators maybe only have a single owner')
        cfg = cfgs.items[0]

        self.model_file = cfg.model_info.file # Path inside container

        output_dir = cfg.prj_info.output_path()

        # If no out_dir has been specified, use adi_cnn
        if cfg.prj_info.out_dir == Path("."):
            output_dir = output_dir / "src" / "adi_cnn"
            report_dir = Path(cfg.prj_info.name) / "src" / "adi_cnn"
        else:
            report_dir = cfg.prj_info.out_dir

        # Get the network configuration file path directly from the config
        self.model_network_config_file = cfg.izer_network_config_file
        if self.model_network_config_file is None:
            raise IzerError(
                "The --izer-network-config option is required for the 'izer' " \
                "backend but was not provided."
            )

        # Get Izer extensions, use default if not provided in config
        if cfg.backend.extensions is not None:
            ta = TypeAdapter(CfsaiIzerExtensions)
            try:
                izer_extensions = ta.validate_python(cfg.backend.extensions)
            except Exception as e:
                raise IzerError(
                    f'config.backend "{cfg.backend}" does not appear to be a' \
                    f' valid CfsaiIzerExtensions \n {e}'
                ) from e
        else:
            izer_extensions = CfsaiIzerExtensions()

        if izer_extensions.input_shape:
            _input_shape = _parse_input_shape(izer_extensions.input_shape)
        else:
            _input_shape = None

        args = CNNGeneratorArgs(
            device=cfg.target.soc, # Should be MAX7800x
            softmax=izer_extensions.softmax,
            timer=izer_extensions.timer,
            prefix=izer_extensions.prefix,
            avg_pool_rounding=izer_extensions.avg_pool_rounding,
            pipeline=izer_extensions.pipeline,
            pll=izer_extensions.pll,
            clock_divider=izer_extensions.clock_divider,
            compact_data=izer_extensions.compact_data,
            config_file=cfg.izer_network_config_file.as_posix() if \
                cfg.izer_network_config_file else None,
            checkpoint_file=cfg.model_info.file.as_posix() \
                if cfg.model_info.file else None,
            test_dir=output_dir.as_posix(),
            overwrite=True,
            input_shape=_input_shape,
            fifo=izer_extensions.fifo
        )
        try:
            codegen(args)
            code_path = output_dir / izer_extensions.prefix
            self.convert_to_cfs(code_path, report_dir)
        except Exception as e:
            raise IzerError(str(e)) from e
