# Copyright (c) 2025 Analog Devices, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import logging
import os
import shutil
import subprocess
from pathlib import Path

from pydantic import TypeAdapter

from cfsai_backend_max7800x.exceptions import IzerError
from cfsai_backend_max7800x.extensions import CfsaiIzerExtensions
from cfsai_types.backend_api import BackendApi
from cfsai_types.config.verified import VerifiedBackendConfig
from cfsai_types.logging import file_created_event

logger = logging.getLogger(__name__)

class IzerApi(BackendApi):
    """Izer backend API implementation."""
    # cmod rw-rw-rw-
    _chmod = 0o666

    def create_dir_with_permissions(self) -> None:
        """
        Creates the provided directory structure, giving any newly created
        directories the appropriate owner and permissions.
        """
        curr = Path("")
        for part in self.output_dir.parts:
            if part == os.sep or part == "":
                continue
            curr = curr / part
            if not curr.exists():
                curr.mkdir(mode=self._chmod)
                os.chown(curr, self._uid, self._gid) # type: ignore

    def convert_to_cfs(
            self, 
            code_path: Path, 
            report_dir: Path, 
        ) -> None:
        """
        Post process the code generated by the ai8x-synthesis tool.
        Rename the main function to cnn_main in the main.c file.
        Also create a cnn-main.h file with the specified content.
        include the following content in cnn-main.h in the main.c file
        Rename the main.c file to cnn-main.c in the specified code path.

        Args:
            code_path: Path to the generated code.
            report_dir: Directory to report generated file.

        Raises:
            IzerError: If the main.c generated file cannot be found.  

        Todo:
            - Are the code_path and report_dir the same arguments ? 
        """
        main_c_file = code_path / 'main.c'
        cnn_main_c_file = code_path / 'cnn-main.c'
        cnn_main_h_file = code_path / 'cnn-main.h'

        # Create cnn-main.h with the specified content
        header_content = (
            "#ifndef CNN_MAIN_H\n"
            "#define CNN_MAIN_H\n"
            "int cnn_main(void);\n"
            "#endif // CNN_MAIN_H\n"
        )
        with open(cnn_main_h_file, 'w') as f:
            f.write(header_content)

        if main_c_file.exists():
            # rename the main function in main.c to cnn_main and include the
            # cnn-main.h file at line 47
            with open(main_c_file, encoding='utf-8') as f:
                content = f.read()
            content = content.replace('int main', 'int cnn_main')

            # Use splitlines to handle newlines consistently
            lines = content.splitlines()
            include_statement = '#include "cnn-main.h"'

            # Insert the include statement at the 47th line of the file
            # Dynamically calculate the insertion index for the include
            # statement (after the last occurrence)
            # The index from reversed list for the line *containing* the
            # last #include
            rev_idx_of_last_include = next(
                (i for i, line in enumerate(reversed(lines)) \
                 if line.strip().startswith('#include')),
                None
            )

            if rev_idx_of_last_include is not None:
                # Convert reversed index to actual line index and insert
                # after it
                actual_idx_of_last_include = len(lines) - 1 - \
                    rev_idx_of_last_include
                insertion_point = actual_idx_of_last_include + 1
            else:
                # No includes found, insert at the beginning of the file
                insertion_point = 0
            lines.insert(insertion_point, include_statement)

            # Write the modified content back to main.c
            with open(main_c_file, 'w') as f:
                f.write('\n'.join(lines))

            main_c_file.rename(cnn_main_c_file)
        else:
            error_message = f"{main_c_file} does not exist."
            raise IzerError(error_message)
        allowed_extensions = {
            '.c', '.h','.cpp', '.hpp','.cc', '.cxx', '.hxx'
        }
        
        for item in code_path.iterdir():
            if item.is_file():
                # Remove the file if it doesn't have an allowed extension
                if item.suffix not in allowed_extensions:
                    item.unlink()
                else:
                    os.chmod(item, self._chmod)
                    os.chown(item, self._uid, self._gid) # type: ignore
                    file_created_event(
                        logger,
                        report_dir / item.name
                    )

            elif item.is_dir():
                # Remove the directory and its contents
                shutil.rmtree(item)

    def get_host_ids(self) -> None:
        """ 
        Record and sanity check host uid and that we can use them.

        Raises:
            IzerError: If host UID or GID are unavailable or aren't integers.
            IzerError: If running on an OS that doesn't support chown or chmod.
        """
        try:
            self._uid = int(str(os.environ.get('HOST_UID')))
            self._gid = int(str(os.environ.get('HOST_GID')))
        except Exception as e:
            raise IzerError(f'Failed getting host UID or GID: {e}')
    
        if not hasattr(os, 'chown'):
            raise IzerError( 'Platform does not support chown')
        if not hasattr(os, 'chmod'):
            raise IzerError( 'Platform does not support chmod')



    def build(self, cfgs: VerifiedBackendConfig) -> None:
        """
        Izer build api implementation.

        Args:
            cfgs: list of verified containerized backend configuration.
        
        Raises:
            IzerError: If the backend configuration has more than one model
                configuration (izer can only target the cnn with one owner).
            IzerError: If izer extensions do not adhere to their schema.
            IzerError: If the model file could not be found.
            IzerError: If code generation failed. 
        """
        if len(cfgs.items) > 1:
            raise IzerError('Accelerators maybe only have a single owner')
        cfg = cfgs.items[0]

        self.get_host_ids()

        self.model_file = cfg.model_info.file # Path inside container
        self.output_dir = cfg.prj_info.output_path() / 'src' / 'adi_cnn'
        self.create_dir_with_permissions()

        # Path to log for file generation
        prj_name = cfg.prj_info.name if cfg.prj_info.name else '.' 
        report_dir = Path(prj_name) / "src" / "adi_cnn"

        # Get the network configuration file path directly from the config
        self.model_network_config_file = cfg.izer_network_config_file
        if self.model_network_config_file is None:
            raise IzerError(
                "The --izer-network-config option is required for the 'izer' " \
                "backend but was not provided."
            )

        # Get Izer extensions, use default if not provided in config
        if cfg.backend.extensions is not None:
            ta = TypeAdapter(CfsaiIzerExtensions)
            try:
                izer_extensions = ta.validate_python(cfg.backend.extensions)
            except Exception as e:
                raise IzerError(
                    f'config.backend "{cfg.backend}" does not appear to be a' \
                    f' valid CfsaiIzerExtensions \n {e}'
                ) from e
        else:
            izer_extensions = CfsaiIzerExtensions()

        # Save the current working directory
        original_cwd = os.getcwd()
        try:
            os.chdir("/ai8x-synthesis")
            model_file_in_container = Path('/mnt/models', self.model_file.name)
            if not model_file_in_container.exists():
                raise IzerError(
                    f"Model file not found at {model_file_in_container}" \
                    " inside the container."
                )

            # Construct the command, ensuring the model file path is correct
            # for the container
            command = [
                '.venv/bin/python', 'ai8xize.py',
                '--no-version-check',
                '--test-dir', str(self.output_dir),
                '--checkpoint-file', str(model_file_in_container),
                '--config-file', str(self.model_network_config_file),
                '--display-checkpoint',
                '--overwrite'
            ]

            # Add arguments from CfsaiIzerExtensions
            command.extend(['--device', cfg.target.soc])

            if izer_extensions.softmax:
                command.append('--softmax')

            if izer_extensions.timer is not None:
                command.extend(['--timer', str(izer_extensions.timer)])

            command.extend(['--prefix', izer_extensions.prefix])

            if izer_extensions.avg_pool_rounding:
                command.append('--avg-pool-rounding')

            if izer_extensions.pipeline is True:
                command.append('--pipeline')
            elif izer_extensions.pipeline is False:
                command.append('--no-pipeline')

            if izer_extensions.pll is True:
                command.append('--pll')
            elif izer_extensions.pll is False:
                command.append('--no-pll')

            # Only add clock_divider if it's not the default of 1
            if izer_extensions.clock_divider is not None and \
                izer_extensions.clock_divider != 1:
                command.extend(
                    ['--clock-divider', str(izer_extensions.clock_divider)]
                )

            if izer_extensions.compact_data:
                command.append('--compact-data')

            # NOTE: The 'section' field in CfsaiIzerExtensions is explicitly
            # noted as not directly used by ai8xize.py. So, it's not added to
            # the command.

            print(f"Running ai8xize.py command: {' '.join(command)}")

            result = subprocess.run(command,
                capture_output=True,
                text=True,
                check=False # Check manually to provide better error message
                )
            if result.returncode != 0:
                error_message = "Izer (ai8xize.py) failed with exit code " \
                    f"{result.returncode}:\n{result.stderr}"
                raise IzerError(error_message)
            code_path = self.output_dir / izer_extensions.prefix
            self.convert_to_cfs(code_path, report_dir)
        except Exception as e:
            stderr_info = ""
            if 'result' in locals() and hasattr(result, 'stderr') and \
                result.stderr:
                stderr_info = "\nStderr from Izer (ai8xize.py):\n" \
                f"{result.stderr}"
            error_message = "Izer build process failed. Original error: " \
            f"{type(e).__name__}: {e!s}{stderr_info}"
            raise IzerError(error_message) from e
        finally:
            os.chdir(original_cwd)
