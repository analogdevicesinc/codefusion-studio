/**
 *
 * Copyright (c) 2024 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {Command, Flags} from '@oclif/core';
import {type CfsConfig, getAiToolsPlugin} from 'cfs-lib';
import {promises as fsp} from 'node:fs';
import path from 'node:path';

import {getDataModelManager} from '../utils/data-model-manager.js';
import {getPackageManager} from '../utils/package-manager.js';
import {getPluginManager} from '../utils/plugin-manager.js';

export default class PinconfigGenerate extends Command {
  static description =
    'Generate source code from the provided .cfsconfig file.';

  static flags = {
    input: Flags.file({
      char: 'i',
      required: true,
      summary: 'Set the .cfsconfig file.'
    }),
    output: Flags.directory({
      char: 'o',
      default: '.',
      summary: 'Set the output directory for generated code.'
    }),
    verbose: Flags.boolean({
      char: 'v',
      summary: 'Display full paths for generated code.'
    }),
    preview: Flags.boolean({
      char: 'p',
      summary: 'Display generated code on stdout.',
      hidden: true
    }),
    format: Flags.string({
      char: 'f',
      default: 'text',
      summary: 'Set the output format for preview.',
      options: ['text', 'json'],
      hidden: true
    }),
    force: Flags.boolean({
      default: false,
      summary: 'Forces file overwrites and folder creation.',
      hidden: true
    }),
    list: Flags.boolean({
      default: false,
      summary:
        'List the filenames that will be generated by the generate command.',
      hidden: true
    }),
    file: Flags.string({
      summary: 'Generate only the specified file.',
      hidden: true
    }),
    'search-path': Flags.string({
      char: 's',
      summary:
        'Specify additional search path. Can be used multiple times.',
      multiple: true // Allows multiple values
    })
  };

  async run() {
    const {flags} = await this.parse(PinconfigGenerate);
    let configdata: CfsConfig;

    try {
      // read input file
      const inputJson = await fsp
        .readFile(flags.input, 'utf8')
        .catch((error) => {
          throw new Error(
            `Could not read input file "${flags.input}".\n${error}`
          );
        });

      // parse input file
      configdata = JSON.parse(inputJson) as CfsConfig;
    } catch (error) {
      throw new Error(
        `Parsing input file "${flags.input}" failed with error:\n${error}`
      );
    }

    // ensure there are no pin conflicts
    const isPinUsed = {} as Record<string, boolean>;
    for (const pin of configdata.Pins) {
      if (isPinUsed[pin.Pin]) {
        this.error(
          `This configuration contains a conflict for pin ${pin.Pin}.`
        );
      }

      isPinUsed[pin.Pin] = true;
    }

    const packageManager = await getPackageManager({
      acceptUndefined: true
    });

    const dmManager = await getDataModelManager(
      this.config,
      packageManager,
      flags['search-path']
    );

    // get the plugin manager
    const pluginManager = getPluginManager(
      flags['search-path'],
      packageManager,
      dmManager
    );

    const soc = await dmManager.getDataModel(
      configdata.Soc,
      configdata.Package
    );

    if (!soc) {
      this.error(
        `SoC data model not found for "${configdata.Soc}" with package "${configdata.Package}"`
      );
    }

    let generatedFiles: string[];

    try {
      generatedFiles = await pluginManager.generateConfigCode(
        {
          cfsconfig: configdata,
          datamodel: soc
        },
        flags.output
      );
    } catch (error) {
      throw new Error(`Failed to generate the files.\n${error}`);
    }

    // TODO change to use the Package Manager later on when cfsai is available as a package
    const cfsaiPath = path.resolve('../../Tools/cfsai');

    const aiPlugin = await getAiToolsPlugin(cfsaiPath);
    if (
      configdata.Projects.some(
        (p) => p.AIModels && p.AIModels.length > 0
      )
    ) {
      const aiFiles = await aiPlugin.generateCode(
        {
          cfsconfig: configdata,
          datamodel: soc
        },
        flags.output
      );
      generatedFiles.push(
        ...aiFiles.map((file) =>
          typeof file === 'string' ? file : file.name
        )
      );
    }

    if (!generatedFiles) {
      this.error(`No files were generated.`);
    }

    if (flags.verbose && Array.isArray(generatedFiles)) {
      for (const file of generatedFiles) {
        this.log(file);
      }
    }
  }
}
