# Copyright (c) 2025 Analog Devices, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# generated by datamodel-codegen:
#   filename:  datamodel-schema.json

from __future__ import annotations

from enum import Enum
from typing import Any, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, NaiveDatetime, RootModel


class Endianness(Enum):
    LITTLE = 'Little'
    BIG = 'Big'


class Part(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Optional[str] = Field(
        None,
        alias='Name',
        description='The part name of this SoC.',
        max_length=20,
        min_length=1,
    )
    package: Optional[str] = Field(
        None,
        alias='Package',
        description='The package used by this SoC. Must correspond to one of the packages described in this file.',
    )
    memory_description: Optional[str] = Field(
        None,
        alias='MemoryDescription',
        description='Description of the memory characteristics of the part.',
        max_length=80,
        min_length=1,
    )


class MemoryType(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the memory type.',
        max_length=20,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the memory type.',
        max_length=80,
        min_length=1,
    )
    is_volatile: bool = Field(
        ..., alias='IsVolatile', description='Whether the memory is volatile or not.'
    )


class MemoryAliasType(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Optional[str] = Field(
        None,
        alias='Name',
        description='The name of the memory alias type.',
        max_length=20,
        min_length=1,
    )
    description: Optional[str] = Field(
        None,
        alias='Description',
        description='The description of the memory alias type.',
        max_length=80,
        min_length=1,
    )


class Type(Enum):
    ENUM = 'enum'
    INTEGER = 'integer'
    BOOLEAN = 'boolean'
    TEXT = 'text'


class EnumValue(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(..., alias='Id', description='The ID of the enumeration value.')
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the enumeration value.',
        max_length=30,
        min_length=1,
    )
    value: int = Field(
        ..., alias='Value', description='The value of the enumeration value.'
    )


class Type1(Enum):
    CORE = 'Core'
    DIVIDER = 'Divider'
    INVERSE_MUX = 'Inverse Mux'
    MULTIPLIER = 'Multiplier'
    MUX = 'Mux'
    OSCILLATOR = 'Oscillator'
    PERIPHERAL = 'Peripheral'
    PIN_INPUT = 'Pin Input'
    PIN_OUTPUT = 'Pin Output'


class Security(Enum):
    ANY = 'Any'
    SECURE = 'Secure'
    NON_SECURE = 'Non-Secure'


class Signal(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The short name for the signal.',
        max_length=15,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the signal.',
        max_length=80,
        min_length=1,
    )
    required: Optional[str] = Field(
        None,
        alias='Required',
        description='If provided, evaluate this condition to determine if signal is required to be assigned. If not provided, signal is assumed to be required.',
        min_length=1,
    )
    group: Optional[str] = Field(
        None,
        alias='Group',
        description='If provided, this signal is part of a signal group. Each signal group can be allocated to a project independently of the parent peripheral. Multiple signals can be part of the same group.',
        max_length=20,
        min_length=1,
    )


class Core1(RootModel[str]):
    root: str = Field(..., min_length=1)


class Size(Enum):
    INTEGER_8 = 8
    INTEGER_16 = 16
    INTEGER_32 = 32
    INTEGER_64 = 64
    INTEGER_128 = 128
    INTEGER_256 = 256


class Access(Enum):
    R = 'R'
    W = 'W'
    X = 'X'
    R_W = 'R/W'
    R_X = 'R/X'
    W_X = 'W/X'
    R_W_X = 'R/W/X'
    W1 = 'W1'
    R_W1 = 'R/W1'


class Position(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    x: int = Field(
        ..., alias='X', description='The x coordinate of the pin on the canvas.'
    )
    y: int = Field(
        ..., alias='Y', description='The y coordinate of the pin on the canvas.'
    )


class Shape(Enum):
    BALL = 'Ball'
    RECTANGLE = 'Rectangle'


class CoprogrammedSignal(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    pin: str = Field(
        ..., alias='Pin', description='The pin name where the signal must be selected.'
    )
    peripheral: str = Field(
        ...,
        alias='Peripheral',
        description='The short name of the peripheral. Must match the name used in the peripherals section.',
    )
    signal: str = Field(
        ...,
        alias='Signal',
        description='The short name of the signal. Must match the name used in the peripherals section.',
    )


class Label(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    text: str = Field(
        ...,
        alias='Text',
        description='The text for the label',
        max_length=10,
        min_length=1,
    )
    x: int = Field(
        ..., alias='X', description='The x coordinate of the label on the canvas.'
    )
    y: int = Field(
        ..., alias='Y', description='The y coordinate of the label on the canvas.'
    )


class PinCanvas(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    width: int = Field(
        ..., alias='Width', description='The width of the canvas, in number of pins.'
    )
    height: int = Field(
        ..., alias='Height', description='The height of the canvas, in number of pins.'
    )
    labels: Optional[list[Label]] = Field(
        None,
        alias='Labels',
        description='A list of labels to place on or around the canvas.',
        min_length=1,
    )
    svg: Optional[str] = Field(
        None, alias='Svg', description='Relative path to the svg file for the package.'
    )


class Address(RootModel[str]):
    root: str = Field(..., max_length=10, min_length=1, pattern='^0[xX][0-9a-fA-F]+$')


class MultiFormatInteger1(RootModel[str]):
    root: str = Field(..., max_length=10, min_length=1, pattern='^0[xX][0-9a-fA-F]+$')


class MultiFormatInteger(RootModel[Union[MultiFormatInteger1, int]]):
    root: Union[MultiFormatInteger1, int]


class Width(Enum):
    INTEGER_8 = 8
    INTEGER_16 = 16
    INTEGER_32 = 32
    INTEGER_64 = 64
    INTEGER_128 = 128
    INTEGER_256 = 256


class Access1(Enum):
    R_W = 'R/W'
    R = 'R'


class Location(Enum):
    INTERNAL = 'Internal'
    EXTERNAL = 'External'


class Memory(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the memory range.',
        max_length=20,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the memory region.',
        max_length=80,
        min_length=1,
    )
    address_start: Address = Field(
        ..., alias='AddressStart', description='The first address in the region.'
    )
    address_end: Address = Field(
        ..., alias='AddressEnd', description='The last address in the region.'
    )
    width: Width = Field(
        ..., alias='Width', description='The bit width of an addressable unit.'
    )
    minimum_alignment: Optional[int] = Field(
        None,
        alias='MinimumAlignment',
        description='The minimum alignment in bytes of partitions of the memory region.',
    )
    access: Access1 = Field(
        ..., alias='Access', description='The accessibility of the memory region.'
    )
    type: str = Field(
        ...,
        alias='Type',
        description='The type category of the memory region. Must be one of the system-level MemoryTypes.',
    )
    location: Location = Field(
        ..., alias='Location', description='The location of the memory region.'
    )


class MemoryReference(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the referenced memory region.',
        max_length=20,
        min_length=1,
    )
    address_start: Optional[Address] = Field(
        None,
        alias='AddressStart',
        description='The first physical address in the region, if different from referenced memory.',
    )
    address_end: Optional[Address] = Field(
        None,
        alias='AddressEnd',
        description='The last physical address in the region, if different from referenced memory.',
    )
    access: Optional[Access1] = Field(
        None, alias='Access', description='The accessibility of the memory region.'
    )
    alias_type: Optional[str] = Field(
        None,
        alias='AliasType',
        description='The reference to the alias for this memory region.',
    )
    alias_base_address: Optional[Address] = Field(
        None,
        alias='AliasBaseAddress',
        description='The base address of the region, if an alias.',
    )


class MemoryRange(RootModel[Union[Memory, MemoryReference]]):
    root: Union[Memory, MemoryReference]


class OpInfo(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ..., alias='Name', description='Name of operator (or operator class)'
    )
    cycles: float = Field(
        ...,
        alias='Cycles',
        description='Estimated number of core cycles to perform operation',
    )
    energy: float = Field(
        ...,
        alias='Energy',
        description='Estimated energy consumed to perform operation (nJ)',
    )


class Operation(Enum):
    WRITE = 'Write'
    READ = 'Read'
    POLL = 'Poll'
    WITH_PREVIOUS = 'WithPrevious'


class ProgrammingSequenceItem(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    register_: Optional[str] = Field(
        None,
        alias='Register',
        description='The register to program. Must match a register name in the registers section.',
    )
    field: Optional[str] = Field(
        None,
        alias='Field',
        description='The field in the register to program. Must match a field name in the register in the registers section.',
    )
    value: Optional[str] = Field(
        None, alias='Value', description='Expression for value to set the field to.'
    )
    inverse_value: Optional[str] = Field(
        None,
        alias='InverseValue',
        description='Expression value to compute the control value from the field value.',
    )
    operation: Operation = Field(
        ..., alias='Operation', description='Apply the operation to the register field.'
    )
    wait: Optional[int] = Field(
        None,
        alias='Wait',
        description='Wait for a given number of milliseconds after the step.',
    )


class ProgrammingSequence(RootModel[list[ProgrammingSequenceItem]]):
    root: list[ProgrammingSequenceItem]


class Ai(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    supported_ops: list[str] = Field(
        ...,
        alias='SupportedOps',
        description='List of Operators supported on code (empty list means all are supported)',
    )
    accel_ops: list[str] = Field(
        ...,
        alias='AccelOps',
        description='List of Operators that can be accelerated (empty list means none are accelerated)',
    )
    flash_size: float = Field(
        ..., alias='FlashSize', description='Total size of on-board flash (KB)'
    )
    ram_size: float = Field(
        ..., alias='RamSize', description='Total size of on-board SRAM (KB)'
    )
    core_clock: float = Field(
        ..., alias='CoreClock', description='Max core clock speed (MHz)'
    )
    operator_infos: list[OpInfo] = Field(
        ...,
        alias='OperatorInfos',
        description='List of Operators (or Operator classes) that have performance metrics',
    )
    supported_data_types: list[str] = Field(
        ...,
        alias='SupportedDataTypes',
        description='List of Data types supported (empty list means all are supported',
    )


class Core(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(
        ...,
        alias='Id',
        description='The short abbreviation for the core, used as an Id.',
        max_length=10,
        min_length=1,
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name for the core, visible in the UI.',
        max_length=20,
        min_length=1,
    )
    family: str = Field(
        ...,
        alias='Family',
        description='The name of the core family e.g. Cortex-M.',
        max_length=80,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the core.',
        max_length=80,
        min_length=1,
    )
    core_num: int = Field(
        ...,
        alias='CoreNum',
        description='The ID number of the core, as seen by the hardware.',
    )
    is_primary: Optional[bool] = Field(
        None, alias='IsPrimary', description='Whether this is the primary core or not.'
    )
    trust_zone: Optional[dict[str, Any]] = Field(
        None, alias='TrustZone', description='Information for TrustZone support.'
    )
    memory: list[MemoryRange] = Field(
        ..., alias='Memory', description='The memory ranges visible to the core.'
    )
    ai: Optional[Ai] = Field(
        None,
        alias='Ai',
        description="Additional AI-related core information. This property's existence marks it as a supported AI-enabled core.",
    )


class InputStream(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    config: dict[str, dict[str, ProgrammingSequence]] = Field(
        ...,
        alias='Config',
        description='The available configuration options for the input stream.',
    )
    built_in_config: dict[str, dict[str, ProgrammingSequence]] = Field(
        ...,
        alias='BuiltInConfig',
        description='The programming sequences for built-in configuration options for the input stream.',
    )
    buffer_start: Optional[int] = Field(
        None, alias='BufferStart', description='The buffer start address, if fixed.'
    )
    buffer_size: Optional[int] = Field(
        None,
        alias='BufferSize',
        description='The size of the circular buffer, if fixed.',
    )


class OutputStream(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    index: int = Field(..., alias='Index', description='The index for this stream.')
    config: dict[str, dict[str, ProgrammingSequence]] = Field(
        ...,
        alias='Config',
        description='The available configuration options for the input stream.',
    )
    built_in_config: dict[str, dict[str, ProgrammingSequence]] = Field(
        ...,
        alias='BuiltInConfig',
        description='The programming sequences for built-in configuration options for the input stream.',
    )
    buffer_start: Optional[int] = Field(
        None, alias='BufferStart', description='The buffer start address, if fixed.'
    )
    buffer_size: Optional[int] = Field(
        None,
        alias='BufferSize',
        description='The size of the circular buffer, if fixed.',
    )


class Gasket(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the gasket instance.',
        max_length=15,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the gasket instance.',
        max_length=80,
        min_length=1,
    )
    associated_core: Optional[str] = Field(
        None,
        alias='AssociatedCore',
        description='The core associated with the gasket instance, if any.',
        max_length=15,
        min_length=1,
    )
    id: int = Field(..., alias='Id', description='The id of the gasket instance.')
    input_buffer_size: int = Field(
        ...,
        alias='InputBufferSize',
        description='The size of the input buffer memory in bytes.',
    )
    min_input_stream_buffer_size: Optional[int] = Field(
        None,
        alias='MinInputStreamBufferSize',
        description='The minimum size of an input stream buffer in bytes.',
    )
    input_and_output_buffers_tied: Optional[bool] = Field(
        None,
        alias='InputAndOutputBuffersTied',
        description='True if the input and output buffers are tied together, false if they can be assigned separately.',
    )
    input_streams: list[InputStream] = Field(..., alias='InputStreams')
    output_buffer_size: int = Field(
        ...,
        alias='OutputBufferSize',
        description='The size of the output buffer memory in bytes.',
    )
    min_output_stream_buffer_size: Optional[int] = Field(
        None,
        alias='MinOutputStreamBufferSize',
        description='The minimum size of an output stream buffer in bytes.',
    )
    output_streams: list[OutputStream] = Field(..., alias='OutputStreams')
    config: Optional[dict[str, dict[str, ProgrammingSequence]]] = Field(
        None,
        alias='Config',
        description='The available configuration options for the gasket.',
    )


class Control(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(..., alias='Id', description='The ID for the control.')
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the control.',
        max_length=80,
        min_length=1,
    )
    type: Type = Field(
        ...,
        alias='Type',
        description='The type of values that can be given to the control.',
    )
    enum_values: Optional[list[EnumValue]] = Field(
        None,
        alias='EnumValues',
        description='The possible values accepted for an enumeration control.',
    )
    minimum_value: Optional[MultiFormatInteger] = Field(
        None, alias='MinimumValue', description='The minimum value of an integer input.'
    )
    maximum_value: Optional[MultiFormatInteger] = Field(
        None, alias='MaximumValue', description='The maximum value of an integer input.'
    )
    units: Optional[str] = Field(
        None,
        alias='Units',
        description='The units used for integer values.',
        max_length=10,
        min_length=1,
    )
    condition: Optional[str] = Field(
        None,
        alias='Condition',
        description='The condition which must be true for the control should be shown, expressed in reverse Polish notation.',
        min_length=1,
    )
    hint: Optional[str] = Field(
        None,
        alias='Hint',
        description='An expression to compute the hint to prepopulate entry boxes.',
        min_length=1,
    )
    pattern: Optional[str] = Field(
        None,
        alias='Pattern',
        description='A regular expression that a text control input must obey.',
        min_length=1,
    )


class Input(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the clock input.',
        max_length=20,
        min_length=1,
    )
    minimum_value: Optional[MultiFormatInteger] = Field(
        None, alias='MinimumValue', description='The minimum value of the input.'
    )
    maximum_value: Optional[MultiFormatInteger] = Field(
        None, alias='MaximumValue', description='The maximum value of the input.'
    )


class Output(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the clock output.',
        max_length=20,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the clock output.',
        max_length=80,
        min_length=1,
    )
    value: str = Field(
        ...,
        alias='Value',
        description='An expression to compute the value of the clock output, expressed in reverse Polish notation.',
        min_length=1,
    )
    minimum_value: Optional[MultiFormatInteger] = Field(
        None, alias='MinimumValue', description='The minimum value of the output.'
    )
    maximum_value: Optional[MultiFormatInteger] = Field(
        None, alias='MaximumValue', description='The maximum value of the output.'
    )
    condition: Optional[str] = Field(
        None,
        alias='Condition',
        description='If false, the output is not used. Expressed in reverse Polish notation.',
        min_length=1,
    )


class ClockNode(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the clock node.',
        max_length=20,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the clock node.',
        max_length=80,
        min_length=1,
    )
    type: Type1 = Field(..., alias='Type', description='The type of this node.')
    inputs: list[Input] = Field(
        ..., alias='Inputs', description='The clock inputs to this node.'
    )
    outputs: list[Output] = Field(
        ..., alias='Outputs', description='The clock outputs from this node.'
    )
    signpost: Optional[str] = Field(
        None,
        alias='Signpost',
        description='Information to display in details view to help user understand what to do.',
        pattern='[A-Z].*\\.',
    )
    initialization: Optional[ProgrammingSequence] = Field(
        None,
        alias='Initialization',
        description='Information on how to initialize the part when this clock node is active. Often used for oscillators.',
    )
    config: Optional[dict[str, dict[str, ProgrammingSequence]]] = Field(
        None,
        alias='Config',
        description='The available configuration options for the clock node.',
    )
    config_ui_order: Optional[list[str]] = Field(
        None,
        alias='ConfigUIOrder',
        description='The order for emitting the UI elements, as a list of control names.',
    )
    config_programming_order: Optional[list[str]] = Field(
        None,
        alias='ConfigProgrammingOrder',
        description='The order for emitting the configuration code, as a list of control names.',
    )


class Peripheral(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The short name of the peripheral.',
        max_length=30,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the peripheral.',
        max_length=80,
        min_length=1,
    )
    clock_node: Optional[str] = Field(
        None,
        alias='ClockNode',
        description='The name of the ClockNode associated with this peripheral, if any.',
        max_length=20,
        min_length=1,
    )
    security: Optional[Security] = Field(
        None,
        alias='Security',
        description='The security level of the peripheral. Defaults to Any.',
    )
    config: Optional[dict[str, dict[str, ProgrammingSequence]]] = Field(
        None,
        alias='Config',
        description='The available configuration options for the clock node.',
    )
    config_programming_order: Optional[list[str]] = Field(
        None,
        alias='ConfigProgrammingOrder',
        description='The order for emitting the configuration code as a list of control names.',
    )
    signals: Optional[list[Signal]] = Field(
        None, alias='Signals', description='The list of signals in this peripheral.'
    )
    cores: list[Core1] = Field(
        ...,
        alias='Cores',
        description='The cores that can have this peripheral assigned to them.',
    )
    preassigned: Optional[bool] = Field(
        None,
        alias='Preassigned',
        description='True if we should preassign this peripheral to the core.',
    )
    initialization: Optional[ProgrammingSequence] = Field(
        None,
        alias='Initialization',
        description='Information on how to initialize the part to use this peripheral.',
    )
    group: Optional[str] = Field(
        None,
        alias='Group',
        description='If provided, this peripheral is part of a peripheral group. Peripheral groups allow tools to show them under a common name to simplify UX.',
        max_length=20,
        min_length=1,
    )
    assignable: Optional[bool] = Field(
        None,
        alias='Assignable',
        description='False if the peripheral cannot be assigned to any core. If not present, it a true value is assumed.',
    )
    required: Optional[list[str]] = Field(
        None,
        alias='Required',
        description='List of peripherals. This indicates that those must be properly initialized for this peripheral to work.',
    )
    ai: Optional[dict[str, Any]] = Field(
        None,
        alias='Ai',
        description="AI accelerator related information. This property's existence, marks the peripheral as an AI accelerator.",
    )


class EnumItem(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Optional[str] = Field(
        None,
        alias='Name',
        description='The name of the enum identifier, all upper case.',
        max_length=80,
        min_length=1,
        pattern='^[0-9A-Z][A-Z_0-9]*$',
    )
    description: Optional[str] = Field(
        None,
        alias='Description',
        description='The description of the enum identifier.',
        max_length=80,
        min_length=1,
    )
    documentation: Optional[str] = Field(
        None,
        alias='Documentation',
        description='The documentation for the enum identifier.',
        pattern='[0-9A-Z].*\\.',
    )
    value: Optional[MultiFormatInteger] = Field(
        None, alias='Value', description='The value of this enumeration identifier.'
    )


class FieldModel(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the field, all upper case.',
        max_length=80,
        min_length=1,
        pattern='^[A-Z][A-Z_0-9]*$',
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the field.',
        max_length=80,
        min_length=1,
    )
    documentation: Optional[str] = Field(
        None,
        alias='Documentation',
        description='The documentation for the field.',
        pattern='[0-9A-Z].*\\.',
    )
    position: int = Field(
        ...,
        alias='Position',
        description='The bit position of the field within the register.',
    )
    length: int = Field(
        ..., alias='Length', description='The length of the field, in bits.'
    )
    access: Access = Field(
        ..., alias='Access', description='The accessibility of the field.'
    )
    reset: MultiFormatInteger = Field(
        ..., alias='Reset', description='The reset value of the field.'
    )
    enum: Optional[list[EnumItem]] = Field(
        None,
        alias='Enum',
        description='The possible enumeration values that this field can take.',
    )


class Register(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the register, all upper case.',
        max_length=80,
        min_length=1,
        pattern='^[A-Z][A-Z_0-9]*$',
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the register.',
        max_length=80,
        min_length=1,
    )
    documentation: Optional[str] = Field(
        None,
        alias='Documentation',
        description='The documentation for the register.',
        pattern='[0-9A-Z].*\\.',
    )
    address: Address = Field(
        ..., alias='Address', description='The address of the register in hexadecimal.'
    )
    size: Size = Field(
        ..., alias='Size', description='The size of the register in bits.'
    )
    fields: Optional[list[FieldModel]] = Field(None, alias='Fields')
    svg: Optional[str] = Field(
        None,
        alias='Svg',
        description='The name of the svg file for the register.',
        max_length=80,
        min_length=1,
    )


class ConfigOptions(RootModel[Optional[dict[str, dict[str, ProgrammingSequence]]]]):
    root: Optional[dict[str, dict[str, ProgrammingSequence]]] = Field(
        None, description='The property name gives the control identifier.'
    )


class Signal1(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    peripheral: str = Field(
        ...,
        alias='Peripheral',
        description='The short name of the peripheral. Must match the name used in the peripherals section.',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The short name of the signal. Must match the name used in the peripherals section.',
    )
    pin_mux_slot: Optional[int] = Field(
        None,
        alias='PinMuxSlot',
        description='The number of the pin mux function, if pin muxed.',
    )
    pin_mux_config: Optional[ProgrammingSequence] = Field(
        None,
        alias='PinMuxConfig',
        description='Information on how to configure the part to use this signal.',
    )
    pin_config: Optional[ConfigOptions] = Field(
        None,
        alias='PinConfig',
        description='The available configuration options for the pin and signal.',
    )
    config_programming_order: Optional[list[str]] = Field(
        None,
        alias='ConfigProgrammingOrder',
        description='The order for emitting the configuration code as a list of control names.',
    )
    is_input_tap: Optional[bool] = Field(
        None,
        alias='IsInputTap',
        description='True if this signal is an input tap, which means it can be assigned in parallel with other signals on this pin.',
    )


class Pin(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ..., alias='Name', description='The pin name.', max_length=10, min_length=1
    )
    label: str = Field(
        ...,
        alias='Label',
        description='The label to attach to the pin.',
        max_length=21,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the pin.',
        max_length=80,
        min_length=1,
    )
    position: Position = Field(
        ..., alias='Position', description='The position of the pin on the package.'
    )
    shape: Shape = Field(
        ..., alias='Shape', description='The physical shape of the pin.'
    )
    gpio_name: Optional[str] = Field(
        None,
        alias='GPIOName',
        description='The GPIO port name, if GPIO. Refers to the GPIO peripheral instance.',
        max_length=10,
        min_length=1,
    )
    gpio_port: Optional[str] = Field(
        None,
        alias='GPIOPort',
        description='The GPIO port number or letter, if GPIO.',
        max_length=1,
        min_length=1,
    )
    gpio_pin: Optional[int] = Field(
        None,
        alias='GPIOPin',
        description='The GPIO pin number on the port, if GPIO.',
        ge=0,
        le=31,
    )
    signals: Optional[list[Signal1]] = Field(
        None,
        alias='Signals',
        description='The list of signals that can be assigned to the pin.',
        min_length=1,
    )


class Package(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The short name of the package.',
        max_length=20,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the package.',
        max_length=80,
        min_length=1,
    )
    num_pins: int = Field(
        ..., alias='NumPins', description='The number of pins in the package.'
    )
    pins: list[Pin] = Field(
        ...,
        alias='Pins',
        description='The definition of the package pins.',
        min_length=1,
    )
    coprogrammed_signals: Optional[list[list[CoprogrammedSignal]]] = Field(
        None,
        alias='CoprogrammedSignals',
        description='Groups of signals/pins that must be selected together.',
    )
    pin_canvas: PinCanvas = Field(
        ..., alias='PinCanvas', description='The definition of the package canvas.'
    )
    clock_canvas: Optional[dict[str, Any]] = Field(
        None,
        alias='ClockCanvas',
        description='The definition of the clock network canvas.',
    )


class CfsDatamodel(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    copyright: str = Field(
        ...,
        alias='Copyright',
        description='The copyright for the file.',
        pattern='Copyright.*Analog Devices.*All rights reserved',
    )
    version: str = Field(
        ...,
        alias='Version',
        description='The version number of the data model file.',
        pattern='[0-9]+\\.[0-9]+\\.[0-9]+-?.*',
    )
    schema_: Literal['1.2.0'] = Field(
        ..., alias='Schema', description='The version number of the data model schema.'
    )
    timestamp: NaiveDatetime = Field(
        ..., alias='Timestamp', description='The time of generation of the file.'
    )
    name: str = Field(
        ...,
        alias='Name',
        description='The name of the part.',
        max_length=20,
        min_length=1,
    )
    description: str = Field(
        ...,
        alias='Description',
        description='The description of the part.',
        max_length=160,
        min_length=1,
    )
    endianness: Endianness = Field(
        ..., alias='Endianness', description='The endianness of the part.'
    )
    parts: list[Part] = Field(
        ..., alias='Parts', description='The SoC parts supported by this file.'
    )
    memory_types: list[MemoryType] = Field(
        ...,
        alias='MemoryTypes',
        description='The type categories of memory used in the UI.',
        min_length=1,
    )
    memory_alias_types: Optional[list[MemoryAliasType]] = Field(
        None,
        alias='MemoryAliasTypes',
        description='The potential alias types for memory regions.',
    )
    system_memory: list[Memory] = Field(
        ..., alias='SystemMemory', description='The system memory available on the SoC.'
    )
    cores: list[Core] = Field(
        ..., alias='Cores', description='The cores available on the SoC.'
    )
    gaskets: Optional[list[Gasket]] = Field(
        None, alias='Gaskets', description='The dataflow gaskets on the part.'
    )
    controls: Optional[dict[str, list[Control]]] = Field(
        None, alias='Controls', description='UI Controls for configuration tools.'
    )
    clock_nodes: Optional[list[ClockNode]] = Field(
        None,
        alias='ClockNodes',
        description='Information on the clock ndoes displayed on the canvas. Ordered in the order that code should be emitted.',
    )
    peripherals: list[Peripheral] = Field(
        ...,
        alias='Peripherals',
        description='The peripherals on the part.',
        min_length=1,
    )
    registers: list[Register] = Field(
        ..., alias='Registers', description='The registers needed for configuration.'
    )
    packages: list[Package] = Field(
        ...,
        alias='Packages',
        description='The packages for the part in this file.',
        min_length=1,
    )
